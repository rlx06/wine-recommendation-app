# -*- coding: utf-8 -*-
"""recommendation system.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1MlZ7smijclLxtzW95OZZdqUnYrFuk0EH
"""

import os
print(os.listdir('/content'))

import pandas as pd

# Load the dataset
file_path = "/content/winemag-data-130k-v2.csv"
df = pd.read_csv(file_path)

# Drop 'region_2' (since we don't need it)
df_france = df_france.drop(columns=['region_2'], errors='ignore')

# Check if df_france is correctly filtered
print(df_france.info())
print(df_france.head())

# Drop columns if they exist
df = df.drop(columns=['region_2', 'taster_twitter_handle'], errors='ignore')

# Check remaining columns
print(df.columns)


# Fill missing prices with the median
df['price'].fillna(df_france['price'].median(), inplace=True)

# Drop rows with missing values in essential columns
df = df.dropna(subset=['country', 'province', 'variety', 'points', 'description'])

print(df.info())  # Check the cleaned dataset

!pip install vaderSentiment

from vaderSentiment.vaderSentiment import SentimentIntensityAnalyzer

# Initialize Sentiment Analyzer
analyzer = SentimentIntensityAnalyzer()

# Function to classify sentiment
def get_sentiment(review):
    score = analyzer.polarity_scores(review)['compound']
    if score > 0.05:
        return 'Positive'
    elif score < -0.05:
        return 'Negative'
    else:
        return 'Neutral'

# Apply sentiment analysis
df['sentiment'] = df['description'].apply(get_sentiment)

# Show sentiment distribution
print(df['sentiment'].value_counts())

print(df[['taster_name', 'title', 'points']].isnull().sum())

# Drop rows where 'taster_name', 'title', or 'points' are missing
df_clean = df.dropna(subset=['taster_name', 'title', 'points'])

# Check dataset size after cleaning
print(df_clean.shape)

# Aggregate duplicate entries by averaging the ratings
df_grouped = df.groupby(['taster_name', 'title'])['points'].mean().reset_index()

# Now pivot the table
ratings_matrix = df_grouped.pivot(index='taster_name', columns='title', values='points').fillna(0)

print(ratings_matrix.shape)  # Check matrix size

# Use the full dataset instead of df_france
df_clean = df.drop(columns=['region_2', 'taster_twitter_handle'], errors='ignore')

# Fill missing prices with the median
df_clean['price'].fillna(df_clean['price'].median(), inplace=True)

# Drop rows with missing values in essential columns
df_clean = df_clean.dropna(subset=['country', 'province', 'variety', 'points', 'description'])

# Ensure 'taster_name' has no NaN values (replace NaNs with 'Unknown Taster')
df_clean['taster_name'].fillna('Unknown Taster', inplace=True)

# Aggregate duplicate ratings
df_grouped = df_clean.groupby(['taster_name', 'title'])['points'].mean().reset_index()

# Pivot the table
ratings_matrix = df_grouped.pivot(index='taster_name', columns='title', values='points').fillna(0)

# Check if the matrix is empty
if ratings_matrix.empty:
    print("⚠️ No valid wine ratings found after filtering!")
else:
    print("✅ Ratings matrix created successfully!")
    print(ratings_matrix.shape)  # Show matrix size

!pip install scikit-learn scipy

from sklearn.neighbors import NearestNeighbors
import numpy as np

# Convert matrix to a numpy array
ratings_matrix_np = ratings_matrix.to_numpy()

# Fit KNN model (metric = cosine similarity)
model_knn = NearestNeighbors(metric='cosine', algorithm='brute')
model_knn.fit(ratings_matrix_np)

print("KNN Model trained successfully!")

from sklearn.decomposition import TruncatedSVD
from sklearn.metrics.pairwise import cosine_similarity

# Apply SVD
svd = TruncatedSVD(n_components=20, random_state=42)
wine_matrix = svd.fit_transform(ratings_matrix)

# Compute similarity
wine_similarity = cosine_similarity(wine_matrix)

# Convert to DataFrame
wine_sim_df = pd.DataFrame(wine_similarity, index=ratings_matrix.index, columns=ratings_matrix.index)

# Transpose the matrix so wines are rows and tasters are columns
ratings_matrix_np = ratings_matrix.T.to_numpy()

# Fit the KNN model
model_knn = NearestNeighbors(metric='cosine', algorithm='brute')
model_knn.fit(ratings_matrix_np)

print(" KNN Model trained successfully!")

print(f"Ratings Matrix Shape: {ratings_matrix.shape}")
print(f"Ratings Matrix Index (rows): {ratings_matrix.index[:5]}")  # Show first 5 row names
print(f"Ratings Matrix Columns (tasters): {ratings_matrix.columns[:5]}")  # Show first 5 column names

# Transpose the matrix so wines are rows and tasters are columns
ratings_matrix = ratings_matrix.T  # Now wines are in rows

from sklearn.neighbors import NearestNeighbors
import numpy as np

# Convert the transposed matrix to a numpy array
ratings_matrix_np = ratings_matrix.to_numpy()

# Fit the KNN model
model_knn = NearestNeighbors(metric='cosine', algorithm='brute')
model_knn.fit(ratings_matrix_np)

print("KNN Model trained successfully!")

# Function to recommend similar wines
def recommend_wines(wine_title, num_recommendations=5):
    if wine_title not in ratings_matrix.index:  # Now, wines are in the index
        return " Wine not found in dataset."

    # Get wine index
    wine_idx = ratings_matrix.index.get_loc(wine_title)

    # Find nearest neighbors
    distances, indices = model_knn.kneighbors(ratings_matrix_np[wine_idx, :].reshape(1, -1), n_neighbors=num_recommendations+1)

    # Get recommended wine titles
    recommended_wines = [ratings_matrix.index[idx] for idx in indices.flatten()[1:]]

    return recommended_wines

# Example: Recommend wines similar to a known title
wine_example = ratings_matrix.index[0]  # Pick the first wine
print(f" Recommendations for: {wine_example}")
print(recommend_wines(wine_example))

# Function to get similar wines
def recommend_wines(wine_title, num_recommendations=5):
    if wine_title not in ratings_matrix.index:  # Now, wines are in the index
        return " Wine not found in dataset."

    # Get wine index
    wine_idx = ratings_matrix.index.get_loc(wine_title)

    # Find nearest neighbors (transpose matrix before passing)
    distances, indices = model_knn.kneighbors(ratings_matrix_np[wine_idx, :].reshape(1, -1), n_neighbors=num_recommendations+1)

    # Get recommended wine titles
    recommended_wines = [ratings_matrix.index[idx] for idx in indices.flatten()[1:]]

    return recommended_wines

# Example: Recommend wines similar to a known title
wine_example = ratings_matrix.index[10]  # Pick a random wine
print(f" Recommendations for: {wine_example}")
print(recommend_wines(wine_example))

def recommend_wines(wine_title, num_recommendations=5):
    if wine_title not in ratings_matrix.columns:
        return f" Wine '{wine_title}' not found in dataset."

    # Get wine index
    wine_index = ratings_matrix.columns.get_loc(wine_title)

    # Find similar wines
    distances, indices = model.kneighbors(ratings_matrix.T.iloc[wine_index, :].values.reshape(1, -1), n_neighbors=num_recommendations+1)

    # Extract recommended wine names
    recommended_wines = [ratings_matrix.columns[i] for i in indices.flatten()[1:num_recommendations+1]]

    return recommended_wines

df[['description', 'sentiment']].sample(10)

recommend_wines("Château Margaux")

# Pick a random wine from the dataset
wine_example = np.random.choice(ratings_matrix.index, 1)[0]

print(f" Recommendations for: {wine_example}")
print(recommend_wines(wine_example, num_recommendations=5))

wine_title = "Stephane Tissot 2011 Singulier Trousseau (Arbois)"

# Check if the wine exists in the dataset
if wine_title in ratings_matrix.columns:
    print(f" '{wine_title}' is in the dataset.")
else:
    print(f" '{wine_title}' NOT found in dataset.")

# Also check dataset column names (if there's a naming mismatch)
print("Sample column names:", ratings_matrix.columns[:10])

!pip install scikit-surprise

from surprise import SVD, Dataset, Reader
from surprise.model_selection import cross_validate

from surprise import SVD, Dataset, Reader
from surprise.model_selection import cross_validate

# Ensure df_all contains all countries
df_all = df[['taster_name', 'title', 'points']].dropna()

# Convert data into Surprise format
reader = Reader(rating_scale=(0, 100))
data = Dataset.load_from_df(df_all, reader)

# Train SVD model with cross-validation
svd = SVD()
cross_validate(svd, data, cv=5, verbose=True)

# Train on the full dataset
trainset = data.build_full_trainset()
svd.fit(trainset)

# Function to predict ratings for a user-wine pair
def predict_rating(taster, wine):
    return svd.predict(taster, wine).est

# Example prediction
example_taster = 'Roger Voss'
example_wine = 'A.R. Lenoble 2008 Grand Cru Blanc de Blancs Chouilly Brut Chardonnay (Champagne)'

print(f"Predicted rating for {example_taster} on {example_wine}: {predict_rating(example_taster, example_wine)}")

# Pick a random wine from the dataset
wine_example = np.random.choice(ratings_matrix.index, 1)[0]

print(f"🔍 Recommendations for: {wine_example}")
print(recommend_wines(wine_example, num_recommendations=5))

from vaderSentiment.vaderSentiment import SentimentIntensityAnalyzer

# Initialize Sentiment Analyzer
analyzer = SentimentIntensityAnalyzer()

# Function to analyze sentiment
def get_sentiment(text):
    scores = analyzer.polarity_scores(text)
    if scores['compound'] >= 0.05:
        return 'positive'
    elif scores['compound'] <= -0.05:
        return 'negative'
    else:
        return 'neutral'

# Apply to dataset
df['sentiment'] = df['description'].apply(get_sentiment)

# Check sentiment distribution
df['sentiment'].value_counts()

!pip install scikit-surprise pandas numpy

import pandas as pd
import numpy as np
from surprise import SVD, Dataset, Reader
from surprise.model_selection import train_test_split
from surprise import accuracy

# Load your dataset
file_path = "/content/winemag-data-130k-v2.csv" # Update if needed
df = pd.read_csv(file_path)

# Drop unwanted column 'region_2' if present
df = df.drop(columns=['region_2'], errors='ignore')

# Check the dataset
print(df.head())

# Convert data to Surprise's required format
reader = Reader(rating_scale=(df['points'].min(), df['points'].max()))
data = Dataset.load_from_df(df[['taster_name', 'title', 'points']], reader)
trainset, testset = train_test_split(data, test_size=0.2)

# Train the SVD model
model = SVD()
model.fit(trainset)

import pandas as pd

# Load dataset
file_path = "/content/winemag-data-130k-v2.csv"  # Update path if needed
df = pd.read_csv(file_path)

# Drop unnecessary columns
df = df.drop(columns=['region_2'], errors='ignore')

# Check available columns
print(df.columns)

import pandas as pd

def interactive_wine_finder(df):
    print("\n🍷 Welcome to the Wine Finder! Let's find the perfect wine for you.\n")

    # Display available options for selection
    countries = df['country'].dropna().unique().tolist()
    varieties = df['variety'].dropna().unique().tolist()
    price_range = f"${df['price'].min()} - ${df['price'].max()}"

    print(f"🌍 Available Countries: {', '.join(countries[:10])}... (and more)")
    country = input("Enter country (or press Enter to skip): ").strip()

    print(f"🍇 Available Varieties: {', '.join(varieties[:10])}... (and more)")
    variety = input("Enter grape variety (or press Enter to skip): ").strip()

    print(f"💰 Available Price Range: {price_range}")
    min_price = input("Enter minimum price (or press Enter to skip): ").strip()
    max_price = input("Enter maximum price (or press Enter to skip): ").strip()

    min_price = float(min_price) if min_price else None
    max_price = float(max_price) if max_price else None

    print("⭐ Available Rating Range: 80 - 100")
    min_rating = input("Enter minimum rating (80-100) (or press Enter to skip): ").strip()
    min_rating = int(min_rating) if min_rating else None

    print("🔍 Characteristics: Enter keywords like 'fruity', 'oak', 'dry', 'full-bodied', etc.")
    keyword = input("Enter any characteristic keyword (or press Enter to skip): ").strip()

    num_results = input("📌 How many recommendations do you want? (default: 5): ").strip()
    num_results = int(num_results) if num_results else 5

    # Apply filters
    filtered_df = df.copy()
    if country:
        filtered_df = filtered_df[filtered_df['country'].str.contains(country, case=False, na=False)]
    if variety:
        filtered_df = filtered_df[filtered_df['variety'].str.contains(variety, case=False, na=False)]
    if min_price:
        filtered_df = filtered_df[filtered_df['price'] >= min_price]
    if max_price:
        filtered_df = filtered_df[filtered_df['price'] <= max_price]
    if min_rating:
        filtered_df = filtered_df[filtered_df['points'] >= min_rating]
    if keyword:
        filtered_df = filtered_df[filtered_df['description'].str.contains(keyword, case=False, na=False)]

    # Sort by rating (highest first) and return results
    filtered_df = filtered_df.sort_values(by='points', ascending=False).head(num_results)

    if filtered_df.empty:
        print("\n❌ No exact matches found. Searching for similar wines...\n")

        # Relax country filter and search again
        filtered_df = df.copy()
        if variety:
            filtered_df = filtered_df[filtered_df['variety'].str.contains(variety, case=False, na=False)]
        if min_price:
            filtered_df = filtered_df[filtered_df['price'] >= min_price]
        if max_price:
            filtered_df = filtered_df[filtered_df['price'] <= max_price]
        if min_rating:
            filtered_df = filtered_df[filtered_df['points'] >= min_rating]
        if keyword:
            filtered_df = filtered_df[filtered_df['description'].str.contains(keyword, case=False, na=False)]

        # Sort by rating again and display suggestions
        filtered_df = filtered_df.sort_values(by='points', ascending=False).head(num_results)

        if filtered_df.empty:
            print("❌ No similar wines found. Try adjusting your filters!")
        else:
            print("✅ Here are some similar wines you may like:")
            print(filtered_df[['title', 'country', 'variety', 'price', 'points', 'description']])
    else:
        print("✅ Here are your recommended wines:")
        print(filtered_df[['title', 'country', 'variety', 'price', 'points', 'description']])

interactive_wine_finder(df)

pip install streamlit

import streamlit as st
import pandas as pd

def find_wines(df, country=None, variety=None, min_price=None, max_price=None, min_rating=None, keyword=None, num_results=5):
    filtered_df = df.copy()
    if country:
        filtered_df = filtered_df[filtered_df['country'].str.contains(country, case=False, na=False)]
    if variety:
        filtered_df = filtered_df[filtered_df['variety'].str.contains(variety, case=False, na=False)]
    if min_price:
        filtered_df = filtered_df[filtered_df['price'] >= min_price]
    if max_price:
        filtered_df = filtered_df[filtered_df['price'] <= max_price]
    if min_rating:
        filtered_df = filtered_df[filtered_df['points'] >= min_rating]
    if keyword:
        filtered_df = filtered_df[filtered_df['description'].str.contains(keyword, case=False, na=False)]

    filtered_df = filtered_df.sort_values(by='points', ascending=False).head(num_results)
    return filtered_df[['title', 'country', 'variety', 'price', 'points', 'description']]

# Load dataset
df = pd.read_csv("/content/winemag-data-130k-v2.csv")  # Update with actual file path

# Streamlit App
st.title("🍷 Wine Recommendation System")
st.write("Find the perfect wine based on your preferences!")

# Sidebar for user input
st.sidebar.header("Filter your wine preferences")
country = st.sidebar.selectbox("Select a country", ["Any"] + sorted(df['country'].dropna().unique().tolist()))
variety = st.sidebar.selectbox("Select a grape variety", ["Any"] + sorted(df['variety'].dropna().unique().tolist()))
min_price = st.sidebar.slider("Minimum Price", min_value=0, max_value=int(df['price'].max()), value=0)
max_price = st.sidebar.slider("Maximum Price", min_value=0, max_value=int(df['price'].max()), value=int(df['price'].max()))
min_rating = st.sidebar.slider("Minimum Rating", min_value=80, max_value=100, value=85)
keyword = st.sidebar.text_input("Enter characteristics (e.g., fruity, oak, dry)")
num_results = st.sidebar.slider("Number of recommendations", min_value=1, max_value=10, value=5)

# Search button
if st.sidebar.button("Find Wines"):
    country = None if country == "Any" else country
    variety = None if variety == "Any" else variety
    results = find_wines(df, country, variety, min_price, max_price, min_rating, keyword, num_results)

    if results.empty:
        st.warning("No matching wines found! Showing similar alternatives.")
        similar_wines = find_wines(df, variety=variety, min_price=min_price, max_price=max_price, min_rating=min_rating, keyword=keyword, num_results=5)
        st.table(similar_wines)
    else:
        st.success("Here are your recommended wines:")
        st.table(results)

